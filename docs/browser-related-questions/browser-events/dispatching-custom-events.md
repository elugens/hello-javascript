---
title: Dispatching Custom Events
sidebar_position: 5
---

# Dispatching Custom Events

**Browser Events: Dispatching Custom Events**

<head>
  <title>Dispatching Custom Events - JavaScript Interview Questions & Answers</title>
  <meta charSet="utf-8" />
</head>

### Explain the function and syntax of the Event constructor.

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> The Event() constructor creates a new Event. We can create custom events or act on built-in events, such as click, mousedown etc. There two arguments the event type (custom or built-in) and the options. The type is a DOMString representing the name of the event. The second argument is the option which includes the bubble, cancelable, and compose option properties all set to false by default.</div><br />
  <div><strong>Technical Response:</strong> Built-in event classes form a hierarchy, like DOM element classes. The root is the built-in Event class. The Event() constructor creates a new Event. We can create custom events or act on built-in events, such as click, mousedown etc. There two arguments the event type (custom or built-in) and the options. The type is a DOMString representing the name of the event. The second argument is the option which includes the bubble, cancelable, and compose option properties. Bubbles is a Boolean indicating whether the event bubbles, the default is false. Cancelable is also a Boolean indicating whether the event can be cancelled. Composed is a Boolean indicating whether the event will trigger listeners outside of a shadow root, which is also false by default.
  </div>
  </div>
</details>

**Syntax:** `const event = new Event("look", {"bubbles":true, "cancelable":false});`

Example:

```js
// create a look event that bubbles up and cannot be canceled

const evt = new Event('look', { bubbles: true, cancelable: false });

document.dispatchEvent(evt);

// event can be dispatched from any element, not only the document

myDiv.dispatchEvent(evt);
```

Source: <https://javascript.info/dispatch-events#event-constructor>

### Explain the function and syntax of the dispatchEvent() method.

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> After an event object is created, we should “run” it on an element using the call elem.dispatchEvent(event). Then handlers react on it as if it were a regular browser event. If the event was created with the bubbles flag, then it bubbles up.
    </div>
  </div>
</details>

**Syntax:** elem.dispatchEvent(event);

Example:

```html
<button id="elem" onclick="alert('Click!');">Autoclick</button>

<script>
  let event = new Event('click');

  elem.dispatchEvent(event);
</script>
```

Source: <https://javascript.info/dispatch-events#dispatchevent>

### Is there a way to tell a “real” user event from a script-generated one?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> Yes, the isTrusted read-only property of the Event interface is a Boolean that is true when the event was generated by a user action, and false when the event was created or modified by a script or dispatched via dispatchEvent() method.
    </div>
  </div>
</details>

**Syntax:** let eventIsTrusted = event.isTrusted;

Example:

```js
if (e.isTrusted) {
  /* The event is trusted */
} else {
  /* The event is not trusted */
}
```

Source: <https://javascript.info/dispatch-events#dispatchevent>

### What is the difference between creating a new Event and a new CustomEvent?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> CustomEvent provides the special detail field for it to evade conflicts with other event properties. In this case, it is the recommended approach. Besides, the event class describes “what kind of event” it is, and if the event is custom, then we should use CustomEvent just to be clear about what it is.</div><br />
  <div><strong>Technical Response:</strong> Technically CustomEvent is the same as Event, with one exception. In the second argument (object) we can add an additional property detail for any custom information that we want to pass with the event. The detail property can have any data. Technically we could live without, because we can assign any properties into a regular new Event object after its creation. But CustomEvent provides the special detail field for it to evade conflicts with other event properties. In this case, it is the recommended approach. Besides, the event class describes “what kind of event” it is, and if the event is custom, then we should use CustomEvent just to be clear about what it is.
  </div>
  </div>
</details>

Example:

```html
<h1 id="elem">Hello for John!</h1>

<script>

  // additional details come with the event to the handler

  elem.addEventListener("hello", function(event) {

    alert(event.detail.name);

  });

  elem.dispatchEvent(new CustomEvent("hello", {

    detail: { name: "John" } ß special detail field

  }));
</script>
```

Source: <https://javascript.info/dispatch-events#custom-events>

### Is there a way to prevent the default behavior of a CustomEvent?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> Yes, you can use event.preventDefault as you would with a regular Event. By calling event.preventDefault(), an event handler may send a signal that those actions should be canceled. In that case the call to elem.dispatchEvent(event) returns false. And the code that dispatched it knows that it should not continue. Please note: the event must have the flag cancelable: true, otherwise the call event.preventDefault() is ignored.
    </div>
  </div>
</details>

Example:

```html
<pre id="rabbit">

    |\   /|
    \|\_/|/
     /. .\
    =\_Y_/=
     {>o<}

</pre>

<button onclick="hide()">Hide()</button>

<script>
  function hide() {
    let event = new CustomEvent('hide', {
      cancelable: true, // without that flag preventDefault doesn't work
    });

    if (!rabbit.dispatchEvent(event)) {
      alert('The action was prevented by a handler');
    } else {
      rabbit.hidden = true;
    }
  }

  rabbit.addEventListener('hide', function (event) {
    if (confirm('Call preventDefault?')) {
      event.preventDefault();
    }
  });
</script>
```

Source: <https://javascript.info/dispatch-events#event-preventdefault>

### Are nested events handled synchronously or asynchronously?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> Nested events are handled synchronously by default. Usually, events are processed in a queue. That is: if the browser is processing onclick and a new event occurs, e.g., mouse moved, then it is handling is queued up, corresponding mousemove handlers will be called after onclick processing is finished. The notable exception is when one event is initiated from within another one, e.g., using dispatchEvent. Such events are processed immediately: the new event handlers are called, and then the current event handling is resumed. However, you can implement asynchronous behavior explicitly by using setTimeout method.
    </div>
  </div>
</details>

Example:

```html
<button id="menu">Menu (click me)</button>

<script>
  menu.onclick = function () {
    alert(1);

    menu.dispatchEvent(
      new CustomEvent('menu-open', {
        bubbles: true,
      })
    );

    alert(2);
  };

  // triggers between 1 and 2

  document.addEventListener('menu-open', () => alert('nested'));
</script>
```

Source: <https://javascript.info/dispatch-events#event-preventdefault>

const StructuredData = {
  '@context': 'https://schema.org',
  '@type': 'FAQPage',
  mainEntity: [
    {
      '@type': 'Question',
      name: 'Is there another option, other than explicit promises, to handle asynchronous code in JavaScript?',
      acceptedAnswer: {
        '@type': 'Answer',
        text: 'Yes, a special syntax to work with promises more comfortably, called “async/await”. It is surprisingly easy to understand and use.',
      },
    },
    {
      '@type': 'Question',
      name: 'Can you explain the syntax and function of an async function?',
      acceptedAnswer: {
        '@type': 'Answer',
        text: 'An async function is a function declared with the async keyword, and the await keyword gets permitted within them. The async and await keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to configure promise chains explicitly. Async functions can contain zero or more await expressions. Await expressions make promise-returning functions seem synchronous by suspending the code execution until the returned promise is fulfilled or rejected. The resolved value of the promise gets treated as a return value of the await expression. Async and await allow you to wrap asynchronous code in regular try/catch statements.',
      },
    },
    {
      '@type': 'Question',
      name: 'What does the await keyword do in asynchronous JavaScript code?',
      acceptedAnswer: {
        '@type': 'Answer',
        text: "The await keyword makes JavaScript wait until that promise settles and returns its result. It's only used within an async function within regular JavaScript code, although it only gets used on its own using JavaScript modules.",
      },
    },
    {
      '@type': 'Question',
      name: 'Is it possible to use the await keyword with regular functions?',
      acceptedAnswer: {
        '@type': 'Answer',
        text: 'No, we cannot use the await keyword in conjunction with a regular functions. JavaScript returns a syntax error if we try to use "await" in the non-async function.',
      },
    },
    {
      '@type': 'Question',
      name: 'How does the await keyword work on top-level code?',
      acceptedAnswer: {
        '@type': 'Answer',
        text: 'The await keyword should not be used directly in top-level code because it is syntactically incorrect and results in an error. We can optionally wrap it in an anonymous async function to make it work properly.',
      },
    },
    {
      '@type': 'Question',
      name: 'Does await accept JavaScript thenables?',
      acceptedAnswer: {
        '@type': 'Answer',
        text: 'Yes, similar to a promise.then, await enables us to use thenable objects (those with a callable then method). The concept is that a third-party object may or may not be a promise, but it must be promise-compatible: if it supports dot then, it may be used with await.',
      },
    },
    {
      '@type': 'Question',
      name: 'Do classes allow asynchronous class methods?',
      acceptedAnswer: {
        '@type': 'Answer',
        text: 'Yes, prepend it with async to declare an async class method. The meaning is the same: it ensures that the returned value is a promise and enables “await”.',
      },
    },
    {
      '@type': 'Question',
      name: 'If a promise resolves with normality, then await promise returns the result. What happens in the case of rejection?',
      acceptedAnswer: {
        '@type': 'Answer',
        text: 'In the case of a rejection, it throws an error. Just as if there were a throw statement at that line. In real situations, the promise may take some time before it rejects, and in that case, there is a delay before await throws an error.',
      },
    },
    {
      '@type': 'Question',
      name: 'Is there a method, other than explicitly throwing an error, to catch problems in async functions dynamically?',
      acceptedAnswer: {
        '@type': 'Answer',
        text: 'Yes, two approaches can be used, including the try…catch method commonly used with promises. We can catch that error using try..catch, the same way as a regular throw. In the case of an error, the control jumps to the catch block. <br /><br />We can also wrap multiple lines to ensure handling of multiple error handling. If we don’t have a try..catch, then the promise generated by the call of the async function f() becomes rejected. We can append .catch to handle it. We can also catch such errors using a global unhandledrejection event handler.',
      },
    },
    {
      '@type': 'Question',
      name: 'When we wait for multiple (array) promises, what can we wrap them into to ensure proper handling (resolve/reject)?',
      acceptedAnswer: {
        '@type': 'Answer',
        text: 'When we need to wait for multiple (array) promises, we can wrap them in Promise.all and then await. In the case of an error, it propagates as usual, from the failed promise to Promise.all. It becomes an exception that we can catch using try..catch around the call.',
      },
    },
  ],
};

export default StructuredData;

---
title: Scheduling / Timing
description: Scheduling / Timing - setTimeout / setInterval is a very common interview
  question. There are two commonly used methods for scheduling calls in
  JavaScript.
sidebar_position: 8
sidebar_label: Scheduling / Timing
keywords:
  - scheduling
  - timing
  - setinterval
  - settimeout
  - functions
  - javascript
  - interview
  - common
  - questions
  - answers
  - response
  - technical
  - function
  - object
  - common interview questions
  - interview questions
  - interview answers
  - js
tags:
  - scheduling
  - timing
  - interview answers
  - interview questions
---

import CloseAllAnswers from '../../../src/components/CloseAnswers/CloseAllAnswers.js';
import JsonLD from '../../../src/components/JsonLD/JsonLD.js';
import StructuredData from './schemadata/SchedulingSchemaData.js';

<JsonLD data={StructuredData} />

<head>
  <title>Scheduling / Timing | JavaScript Frontend Phone Interview</title>
</head>

**Advanced Functions: Scheduling: setTimeout / setInterval**

<CloseAllAnswers />

### What are the two most common JavaScript methods used for scheduling a call?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> The two most common JavaScript methods for scheduling a call are setTimeout() for single delayed execution and setInterval() for repeated execution at specified intervals.</div><br/>
  <div><strong>Technical Response:</strong> There are two commonly used methods for scheduling calls in JavaScript, including the setTimeout and setInterval methods. setTimeout allows us to run a function once after the interval of time. setInterval allows us to run a function repeatedly, starting after the interval of time, then repeating continuously at that interval. Both methods are helpful when you need to schedule specific events or actions in JavaScript. These methods donâ€™t get included in the JavaScript specification. However, most settings have an internal scheduler, and these methods are available. All browsers, as well as Node.js, support them. Both methods are part of the WindowOrGlobalScope interface as a specification.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
setTimeout(function() {
  // Code to be executed after the delay
}, 3000); // Delay of 3000 milliseconds (3 seconds)

setInterval(function() {
  // Code to be executed repeatedly at the specified interval
}, 5000); // Interval of 5000 milliseconds (5 seconds)
```

  </div>
  </div>
</details>

---

### What is the difference between setTimeout and setInterval in JavaScript?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> The setTimeout method schedules a single function execution after a specified delay, while setInterval method schedules a function to execute repeatedly at specified intervals, enabling continuous updates or recurring tasks.
  </div>
  </div>
</details>

---

### Can you explain the function of the setTimeout() method?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> The setTimeout method schedules a single function execution after a specified delay, while setInterval method schedules a function to execute repeatedly at specified intervals, enabling continuous updates or recurring tasks.</div><br />
  <div><strong>Technical Response:</strong> The setTimeout() function of the WindowOrWorkerGlobalScope mixin (the Window. setTimeout()) creates a timer that, when it expires, executes a function or provides a piece of code. The func/code, delay (optional), and several optional arguments are all parameters. The func / code must be present, but the delay and optional arguments are not. If the delay option is not specified, a value of 0 is used, which means that the event is executed immediately, or more precisely, the following event cycle. You should note that the actual delay may be greater than anticipated in any instance. The timerID returned by setTimeout() is a positive integer value that identifies the timer generated by the call; this value may be provided to clearTimeout() to cancel the timeout.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

<strong>Syntax: </strong> let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);<br /><br />

  <div></div>

```js
function sayHi() {
  alert('Hello');
}

setTimeout(sayHi, 1000);

// setTimeout without arguments:

function sayHi(phrase, who) {
  alert(phrase + ', ' + who);
}

setTimeout(sayHi, 1000, 'Hello', 'John'); // Hello, John

// Arrow function implementation
setTimeout(() => alert('Hello'), 1000);
```

  </div>

:::note
We can use the clearTimeout method to clear setTimeout in our code.
:::

  </div>
</details>

---

### How do you cancel a scheduled setTimeout call?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> To cancel a scheduled setTimeout call, you can use the clearTimeout() method, passing the timeout identifier returned by the corresponding setTimeout() invocation as its argument.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
// Schedule a function to be executed after 5 seconds
var timeoutId = setTimeout(function() {
  console.log("Scheduled function executed.");
}, 5000);

// Cancel the scheduled setTimeout call
clearTimeout(timeoutId);
```

  </div>
  </div>
</details>

---

### Can you explain the function of the clearTimeout() method?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> The clearTimeout() method cancels a previously scheduled setTimeout() call, preventing the associated function or code snippet from executing after the specified delay.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
let timerID = setTimeout(() => alert('never happens'), 1000);
alert(timerID); // timer identifier

clearTimeout(timerID);
alert(timerID); // same identifier (does not become null after canceling)
```

:::note
It's worth noting that the pool of IDs used by setTimeout() and setInterval() are shared, which means you can technically use clearTimeout() and clearInterval() interchangeably. However, for clarity, you should avoid doing so.
:::

  </div>
  </div>
</details>

---

### Can you explain the function of the setInterval() method?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> The setInterval() method schedules a function or code snippet to execute repeatedly at specified intervals, measured in milliseconds, allowing for recurring tasks or continuous updates.</div><br />
  <div><strong>Technical Response:</strong> The setInterval method has the same syntax as setTimeout. Parameters include the func/code, delay (optional), and some optional arguments. The func / code is required, but delay and optional arguments are not. The time, in milliseconds (thousandths of a second), the timer should delay in between executions of the specified function or code. See Delay restrictions below for details on the acceptable range of delay values. All arguments have the same meaning. But unlike setTimeout it runs the function not only once but regularly after the given interval of time. To stop further calls, we should call clearInterval(timerId).
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

<strong>Syntax: </strong> let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);<br /><br />

  <div></div>

```js
// repeat with the interval of 2 seconds
let timerId = setInterval(() => alert('tick'), 2000);

// after 5 seconds stop
setTimeout(() => {
  clearInterval(timerId);
  alert('stop');
}, 5000);
```

  </div>
  </div>
</details>

---

### How does garbage collection work with the setInterval and setTimeout callbacks?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> Garbage collection in JavaScript retains setInterval and setTimeout callbacks until they execute or are cleared, preventing memory leaks and ensuring proper execution of scheduled tasks.</div><br />
  <div><strong>Technical Response:</strong> When a function gets passed in setInterval/setTimeout, an internal reference is created to it and saved in the scheduler. It prevents the function from being garbage collected, even if there are no other references to it. For setInterval the function stays in memory until clearInterval gets called. There is a side-effect. A function references the outer lexical environment, so, while it lives, outer variables live too. They may take much more memory than the function itself. So, when we do not need the scheduled function anymore, it is better to cancel it, even if it is small.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
// the function stays in memory until the scheduler calls it

// Example using setInterval
function doRepeatedTask() {
  console.log("Executing repeated task...");
}

// Schedule a repeated task every 1 second
var intervalId = setInterval(doRepeatedTask, 1000);

// Clear the interval after 5 seconds
setTimeout(function() {
  clearInterval(intervalId);
  console.log("Interval cleared after 5 seconds.");
}, 5000);

```

:::note
There is a side-effect. A function references the outer lexical environment, so, while it lives, outer variables live too, and they may take much more memory than the function itself. So, when we do not need the scheduled function anymore, it is better to cancel it, even if it's minimal.
:::

  </div>
  </div>
</details>

---

### How does zero delay setTimeout execute in JavaScript?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> A zero delay setTimeout defers the execution of the callback function until the current call stack is clear, effectively making it asynchronous and allowing other tasks to run first.
</div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
setTimeout(() => console.log('JavaScript!')); // returns second

console.log('Hello'); // returns first
```

:::note
There are also advanced browser-related use cases of the zero-delay timeout, such as splitting CPU-hungry tasks.
:::

  </div>
  </div>
</details>

---

### How do you cancel a scheduled setInterval() call?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> To cancel a scheduled setInterval call, we invoke the clearInterval() method with the interval identifier as its argument, which is the value returned by the corresponding setInterval() call that initiated the repetition.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
// Schedule a repeated task every 1 second
var intervalId = setInterval(function() {
  console.log("Executing repeated task...");
}, 1000);

// Cancel the scheduled interval after 5 seconds
setTimeout(function() {
  clearInterval(intervalId);
  console.log("Interval canceled after 5 seconds.");
}, 5000);
```

  </div>
  </div>
</details>

---

### How can you create a recursive setTimeout to mimic setInterval behavior?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> We can create a recursive setTimeout by scheduling a new setTimeout call within the callback function itself, ensuring it executes repeatedly with the desired delay, thereby mimicking setInterval behavior.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
function recursiveSetTimeout(callback, delay) {
  setTimeout(function() {
    callback();
    recursiveSetTimeout(callback, delay);
  }, delay);
}

// Example usage
recursiveSetTimeout(function() {
  console.log('Recursive setTimeout example');
}, 1000);

```

<p>In the above example, the recursiveSetTimeout function schedules the execution of the provided callback function repeatedly with the specified delay, effectively mimicking the behavior of setInterval. Each iteration schedules the next execution by calling recursiveSetTimeout recursively inside the callback function.</p>

  </div>
  </div>
</details>

---

### What is the minimum delay for setTimeout and setInterval in modern browsers?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> The minimum delay for setTimeout and setInterval in modern browsers is four milliseconds, after the 5th call, due to browser-imposed limitations on timers.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
// Minimum delay for setTimeout
setTimeout(function() {
  console.log("Minimum delay reached for setTimeout");
}, 4);

// Minimum delay for setInterval
var counter = 0;
var intervalId = setInterval(function() {
  console.log("Minimum delay reached for setInterval");
  counter++;
  if (counter === 5) {
    clearInterval(intervalId);
    console.log("Interval cleared after 5 iterations.");
  }
}, 4);
```

  </div>
  </div>
</details>

---

### How can you throttle or debounce functions using setTimeout?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> To throttle or debounce functions using setTimeout, wrap the original function in a higher-order function that uses setTimeout to delay the function call, ensuring a minimum delay between successive calls, reducing the frequency of execution.
  </div><br />
  <div><strong className="codeExample">Simple Code Example:</strong><br /><br />

  <div></div>

**1. Debounce Example**

```js
function debounce(func, timeout = 300){
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => { func.apply(this, args); }, timeout);
  };
}
function saveInput(){
  console.log('Saving data');
}
const processChange = debounce(() => saveInput());
```

**2. Throttle Example**

```js
function throttle(callback, delay = 1000) {
  let shouldWait = false;

  return (...args) => {
    if (shouldWait) return;

    callback(...args);
    shouldWait = true;
    setTimeout(() => {
      shouldWait = false;
    }, delay);
  };
}
```

  </div>
  </div>
</details>

---

### How does JavaScript's event loop work with setTimeout and setInterval?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> The setTimeout and setInterval methods are added to the message queue by the event loop after the specified delay, allowing the JavaScript engine to execute other tasks while waiting for the timer to expire.
  </div>
  </div>
</details>

---

### What is the impact of using setInterval on browser performance?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> Using setInterval can cause performance issues, especially if the interval duration is too short, leading to higher CPU and memory usage and reduced user experience, especially on low-end devices.
  </div>
  </div>
</details>

---

### How can you handle errors in setTimeout and setInterval callbacks?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> We can wrap the callback function in a try-catch block to handle errors in setTimeout and setInterval callbacks. Alternatively, utilize error handling mechanisms like window.onerror or try-catch in the outer scope of the callback.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
setTimeout(() => {
  try {
    let code = null;
    console.log(code.hello); // this will fail
  } catch (error) {
    // Handle the error
      console.log(error.name); // TypeError
      console.log(error.stack); // TypeError: Cannot read properties of null (reading 'hello') at <anonymous>:4:24
  }
}, 4);
```

  </div>
  </div>
</details>

---

### How do setTimeout and setInterval interact with Promises and async/await?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> When used in conjunction with Promises and async/await, the setTimeout and setInterval methods return a Promise or an Async Function, respectively, allowing for more precise control over the timing of code execution.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function myFunction() {
  console.log('Before delay');
  await delay(2000); // Wait for 2 seconds
  console.log('After delay');
}

myFunction();
```

  </div>
  </div>
</details>

---

### Can you explain the use cases of requestAnimationFrame and its advantages over setInterval for animations?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> The requestAnimationFrame method is designed for animation use cases, ensuring smooth, optimized performance at a consistent frame rate. It reduces CPU and GPU usage, improves battery life, and avoids flickering and jank associated with setInterval.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
const element = document.getElementById('animationElement');
let start;

function step(timestamp) {
  if (start === undefined) start = timestamp;
  const elapsed = timestamp - start;

  // `Math.min()` is used here to make sure that the element stops at exactly 200px.
  element.style.transform =
    'translateX(' + Math.min(0.1 * elapsed, 200) + 'px)';

  if (elapsed < 2000) {
    // Stop the animation after 2 seconds
    window.requestAnimationFrame(step);
  }
}

window.requestAnimationFrame(step);
```

  </div>
  </div>
</details>

---

### What are the differences between using setTimeout and requestIdleCallback for scheduling low-priority tasks?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> setTimeout schedules tasks to run after a specified delay, while requestIdleCallback schedules tasks to run during idle periods when the browser has free CPU time, optimizing for performance and user experience.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
function myCallback() {
  // do something when the browser is idle
}

requestIdleCallback(myCallback);
```

  </div>
  </div>
</details>

---

### How do you measure the elapsed time between two events in JavaScript?

<details>
  <summary><strong>View Answer:</strong></summary>
  <div>
  <div><strong>Interview Response:</strong> To measure elapsed time between two events in JavaScript, store the current timestamp using the 'Date.now()' or 'performance.now()' methods and subtract it from the timestamp at the end of the event.
  </div><br />
  <div><strong className="codeExample">Code Example:</strong><br /><br />

  <div></div>

```js
// Capture the start time
const startTime = performance.now();

for(let i = 0; i < 10000; i++) {
    console.log(i);
}

// Capture the end time
const endTime = performance.now();

// Calculate the elapsed time
const elapsed = endTime - startTime;

console.log('Elapsed time:', elapsed, 'milliseconds'); // Elapsed time: 211.9000000357628 milliseconds
```

  </div>
  </div>
</details>

---
